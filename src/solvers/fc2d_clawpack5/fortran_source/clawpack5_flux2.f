c
c
c     =====================================================
      subroutine clawpack5_flux2(ixy,maxm,meqn,maux,mbc,mx,
     &                 q1d,dtdx1d,aux1,aux2,aux3,
     &                 faddm,faddp,gaddm,gaddp,cfl1d,wave,s,
     &                 amdq,apdq,cqxx,bmasdq,bpasdq,rpn2,rpt2)
c     =====================================================
c
c     # clawpack routine ...  modified for AMRCLAW
c
c     # Compute the modification to fluxes f and g that are generated by
c     # all interfaces along a 1D slice of the 2D grid. 
c     #    ixy = 1  if it is a slice in x
c     #          2  if it is a slice in y
c     # This value is passed into the Riemann solvers. The flux modifications
c     # go into the arrays fadd and gadd.  The notation is written assuming
c     # we are solving along a 1D slice in the x-direction.
c
c     # fadd(*,i,.) modifies F to the left of cell i
c     # gadd(*,i,.,1) modifies G below cell i
c     # gadd(*,i,.,2) modifies G above cell i
c
c     # The method used is specified by method(2:3):
c
c         method(2) = 1 if only first order increment waves are to be used.
c                   = 2 if second order correction terms are to be added, with
c                       a flux limiter as specified by mthlim.  
c
c         method(3) = 0 if no transverse propagation is to be applied.
c                       Increment and perhaps correction waves are propagated
c                       normal to the interface.
c                   = 1 if transverse propagation of increment waves 
c                       (but not correction waves, if any) is to be applied.
c                   = 2 if transverse propagation of correction waves is also
c                       to be included.  
c
c     Note that if mcapa>0 then the capa array comes into the second 
c     order correction terms, and is already included in dtdx1d:
c     If ixy = 1 then
c        dtdx1d(i) = dt/dx                      if mcapa= 0
c                  = dt/(dx*aux(mcapa,i,jcom))  if mcapa = 1
c     If ixy = 2 then
c        dtdx1d(j) = dt/dy                      if mcapa = 0
c                  = dt/(dy*aux(mcapa,icom,j))  if mcapa = 1
c
c     Notation:
c        The jump in q (q1d(i,:)-q1d(i-1,:))  is split by rpn2 into
c            amdq =  the left-going flux difference  A^- Delta q  
c            apdq = the right-going flux difference  A^+ Delta q  
c        Each of these is split by rpt2 into 
c            bmasdq = the down-going transverse flux difference B^- A^* Delta q
c            bpasdq =   the up-going transverse flux difference B^+ A^* Delta q
c        where A^* represents either A^- or A^+.
c
c
      use clawpack5_amr_module
      implicit none

      external rpn2, rpt2

      integer ixy,maxm,meqn,maux,mbc,mx
      double precision     q1d(meqn,1-mbc:maxm+mbc)
      double precision    amdq(meqn,1-mbc:maxm+mbc)
      double precision    apdq(meqn,1-mbc:maxm+mbc)
      double precision  bmasdq(meqn,1-mbc:maxm+mbc)
      double precision  bpasdq(meqn,1-mbc:maxm+mbc)
      double precision    cqxx(meqn,1-mbc:maxm+mbc)
      double precision   faddm(meqn,1-mbc:maxm+mbc)
      double precision   faddp(meqn,1-mbc:maxm+mbc)
      double precision   gaddm(meqn,1-mbc:maxm+mbc, 2)
      double precision   gaddp(meqn,1-mbc:maxm+mbc, 2)
      double precision dtdx1d(1-mbc:maxm+mbc)
      double precision aux1(maux,1-mbc:maxm+mbc)
      double precision aux2(maux,1-mbc:maxm+mbc)
      double precision aux3(maux,1-mbc:maxm+mbc)
c
      double precision     s(mwaves, 1-mbc:maxm+mbc)
      double precision  wave(meqn, mwaves, 1-mbc:maxm+mbc)
c
      logical limit

      double precision dtcom, dxcom , dycom, tcom
      integer icom, jcom
      common /comxyt/ dtcom,dxcom,dycom,tcom,icom,jcom

      integer mw, i, m
      double precision cfl1d, dtdxave, abs_sign, gupdate
c
      limit = .false.
      do mw = 1,mwaves
         if (mthlim(mw) .gt. 0) then
            limit = .true.
         endif
      end do
c

c     # initialize flux increments:
c     -----------------------------
c
       do i = 1-mbc, mx+mbc
         do m = 1,meqn
            faddm(m,i) = 0.d0
            faddp(m,i) = 0.d0
            gaddm(m,i,1) = 0.d0
            gaddp(m,i,1) = 0.d0
            gaddm(m,i,2) = 0.d0
            gaddp(m,i,2) = 0.d0
         end do
      end do
c
c
c     # solve Riemann problem at each interface and compute Godunov updates
c     ---------------------------------------------------------------------
c
      call rpn2(ixy,maxm,meqn,mwaves,maux,mbc,mx,q1d,q1d,
     &          aux2,aux2,wave,s,amdq,apdq)
c
c     # Set fadd for the donor-cell upwind method (Godunov)
      do i = 1,mx+1
         do m = 1,meqn
            faddp(m,i) = faddp(m,i) - apdq(m,i)
            faddm(m,i) = faddm(m,i) + amdq(m,i)
         end do
      end do
c
c     # compute maximum wave speed for checking Courant number:
      cfl1d = 0.d0
      do mw = 1,mwaves
         do i = 1,mx+1
c          # if s>0 use dtdx1d(i) to compute CFL,
c          # if s<0 use dtdx1d(i-1) to compute CFL:
            cfl1d = dmax1(cfl1d, dtdx1d(i)*s(mw,i),
     &                          -dtdx1d(i-1)*s(mw,i))
         end do
      end do
c
      if (method(2).eq.1) go to 130
c
c     # modify F fluxes for second order q_{xx} correction terms:
c     -----------------------------------------------------------
c
c     # apply limiter to waves:
c     # !!! Change to call clawpack5_limiter (original:limiter)
      if (limit) call clawpack5_inlinelimiter(maxm,meqn,mwaves,mbc,mx,
     &      wave,s,mthlim)
c
      do  i = 1, mx+1
c
c        # For correction terms below, need average of dtdx in cell
c        # i-1 and i.  Compute these and overwrite dtdx1d:
c
c        # modified in Version 4.3 to use average only in cqxx, not transverse
         dtdxave = 0.5d0 * (dtdx1d(i-1) + dtdx1d(i))

c
c        # second order corrections:

         do m = 1,meqn
            cqxx(m,i) = 0.d0
            do mw=1,mwaves
c
               if (use_fwaves) then
                   abs_sign = dsign(1.d0,s(mw,i))
               else
                   abs_sign = dabs(s(mw,i))
               endif

               cqxx(m,i) = cqxx(m,i) + abs_sign
     &             * (1.d0 - dabs(s(mw,i))*dtdxave) * wave(m,mw,i)
             end do
             faddm(m,i) = faddm(m,i) + 0.5d0 * cqxx(m,i)
             faddp(m,i) = faddp(m,i) + 0.5d0 * cqxx(m,i)
         end do
      end do
c
c
  130  continue
c
       if (method(3).eq.0) go to 999   !# no transverse propagation
c
       if (method(2).gt.1 .and. method(3).eq.2) then
c         # incorporate cqxx into amdq and apdq so that it is split also.
          do i = 1, mx+1
             do m=1,meqn
                amdq(m,i) = amdq(m,i) + cqxx(m,i)
                apdq(m,i) = apdq(m,i) - cqxx(m,i)
             end do
          end do
       endif
c
c
c      # modify G fluxes for transverse propagation
c      --------------------------------------------
c
c
c     # split the left-going flux difference into down-going and up-going:
      call rpt2(ixy,1,maxm,meqn,mwaves,maux,mbc,mx,
     &          q1d,q1d,aux1,aux2,aux3,
     &          amdq,bmasdq,bpasdq)
c
c     # modify flux below and above by B^- A^- Delta q and  B^+ A^- Delta q:
      do i = 1, mx+1
         do m=1,meqn
               gupdate = 0.5d0*dtdx1d(i-1) * bmasdq(m,i)
               gaddm(m,i-1,1) = gaddm(m,i-1,1) - gupdate
               gaddp(m,i-1,1) = gaddp(m,i-1,1) - gupdate
c
               gupdate = 0.5d0*dtdx1d(i-1) * bpasdq(m,i)
               gaddm(m,i-1,2) = gaddm(m,i-1,2) - gupdate
               gaddp(m,i-1,2) = gaddp(m,i-1,2) - gupdate
            end do
      end do
c
c     # split the right-going flux difference into down-going and up-going:
      call rpt2(ixy,2,maxm,meqn,mwaves,maux,mbc,mx,
     &          q1d,q1d,aux1,aux2,aux3,
     &          apdq,bmasdq,bpasdq)
c
c     # modify flux below and above by B^- A^+ Delta q and  B^+ A^+ Delta q:
       do i = 1, mx+1
          do m=1,meqn
               gupdate = 0.5d0*dtdx1d(i) * bmasdq(m,i)
               gaddm(m,i,1) = gaddm(m,i,1) - gupdate
               gaddp(m,i,1) = gaddp(m,i,1) - gupdate
c
               gupdate = 0.5d0*dtdx1d(i) * bpasdq(m,i)
               gaddm(m,i,2) = gaddm(m,i,2) - gupdate
               gaddp(m,i,2) = gaddp(m,i,2) - gupdate
         end do
      end do
c
  999 continue
      return
      end
