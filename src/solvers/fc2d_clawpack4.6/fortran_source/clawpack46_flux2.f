c
c
c     =====================================================
      subroutine clawpack46_flux2(ixy,maxm,meqn,maux,mbc,mx,
     &      q1d,dtdx1d,aux1,aux2,aux3, faddm,faddp,gaddm,gaddp,
     &      cfl1d,wave,s,amdq,apdq,cqxx,bmasdq,bpasdq,
     &      rpn2,rpt2,mwaves,mcapa,method,mthlim)
c     =====================================================
c
c     # clawpack routine ...  modified for AMRCLAW
c
c     # Compute the modification to fluxes f and g that are generated by
c     # all interfaces along a 1D slice of the 2D grid.
c     #    ixy = 1  if it is a slice in x
c     #          2  if it is a slice in y
c     # This value is passed into the Riemann solvers. The flux modifications
c     # go into the arrays fadd and gadd.  The notation is written assuming
c     # we are solving along a 1D slice in the x-direction.
c
c     # fadd(i,.) modifies F to the left of cell i
c     # gadd(i,.,1) modifies G below cell i
c     # gadd(i,.,2) modifies G above cell i
c
c     # The method used is specified by method(2:3):
c
c         method(2) = 1 if only first order increment waves are to be used.
c                   = 2 if second order correction terms are to be added, with
c                       a flux limiter as specified by mthlim.
c
c         method(3) = 0 if no transverse propagation is to be applied.
c                       Increment and perhaps correction waves are propagated
c                       normal to the interface.
c                   = 1 if transverse propagation of increment waves
c                       (but not correction waves, if any) is to be applied.
c                   = 2 if transverse propagation of correction waves is also
c                       to be included.
c
c     Note that if mcapa>0 then the capa array comes into the second
c     order correction terms, and is already included in dtdx1d:
c     If ixy = 1 then
c        dtdx1d(i) = dt/dx                      if mcapa= 0
c                  = dt/(dx*aux(i,jcom,mcapa))  if mcapa = 1
c     If ixy = 2 then
c        dtdx1d(j) = dt/dy                      if mcapa = 0
c                  = dt/(dy*aux(icom,j,mcapa))  if mcapa = 1
c
c     Notation:
c        The jump in q (q1d(i,:)-q1d(i-1,:))  is split by rpn2 into
c            amdq =  the left-going flux difference  A^- Delta q
c            apdq = the right-going flux difference  A^+ Delta q
c        Each of these is split by rpt2 into
c            bmasdq = the down-going transverse flux difference B^- A^* Delta q
c            bpasdq =   the up-going transverse flux difference B^+ A^* Delta q
c        where A^* represents either A^- or A^+.
c
c
      implicit none

      integer ixy, maxm, meqn, mbc, mx, maux
      integer mwaves, mcapa, method(7), mthlim(mwaves)

      external rpn2, rpt2
      double precision    q1d(1-mbc:maxm+mbc, meqn)
      double precision   amdq(1-mbc:maxm+mbc, meqn)
      double precision   apdq(1-mbc:maxm+mbc, meqn)
      double precision bmasdq(1-mbc:maxm+mbc, meqn)
      double precision bpasdq(1-mbc:maxm+mbc, meqn)
      double precision   cqxx(1-mbc:maxm+mbc, meqn)
      double precision   faddm(1-mbc:maxm+mbc, meqn)
      double precision   faddp(1-mbc:maxm+mbc, meqn)
      double precision   gaddm(1-mbc:maxm+mbc, meqn, 2)
      double precision   gaddp(1-mbc:maxm+mbc, meqn, 2)
      double precision dtdx1d(1-mbc:maxm+mbc)
      double precision aux1(1-mbc:maxm+mbc, maux)
      double precision aux2(1-mbc:maxm+mbc, maux)
      double precision aux3(1-mbc:maxm+mbc, maux)
c
      double precision     s(1-mbc:maxm+mbc, mwaves)
      double precision  wave(1-mbc:maxm+mbc, meqn, mwaves)

      double precision dtcom, dxcom, dycom, tcom
      integer icom, jcom
      common /comxyt/ dtcom,dxcom,dycom,tcom,icom,jcom


      integer ilr, mw, jside, m, i
      double precision cfl1d, gupdate,dtdxave
      logical limit

c
      limit = .false.
      do mw = 1,mwaves
         if (mthlim(mw) .gt. 0) then 
            limit = .true.
        end if
      end do
c
c     # initialize flux increments:
c     -----------------------------
c
      do jside=1,2
         do m = 1,meqn
            do i = 1-mbc, mx+mbc
               faddm(i,m) = 0.d0
               faddp(i,m) = 0.d0
               gaddm(i,m,jside) = 0.d0
               gaddp(i,m,jside) = 0.d0
            end do
         end do
      end do
c
c
c     # solve Riemann problem at each interface and compute Godunov updates
c     ---------------------------------------------------------------------
c
      call rpn2(ixy,maxm,meqn,mwaves,mbc,mx,q1d,q1d,
     &          aux2,aux2,wave,s,amdq,apdq)

c
c     # Set fadd for the donor-cell upwind method (Godunov)
      do i = 2-mbc, mx+mbc-1
         do m = 1,meqn
            faddp(i,m) = faddp(i,m) - apdq(i,m)
            faddm(i,m) = faddm(i,m) + amdq(i,m)
         end do
      end do
c
c     # compute maximum wave speed for checking Courant number:
      cfl1d = 0.d0
      do mw = 1,mwaves
c         !! We sweep over ghost cells so code will compare
c         !! with cudaclaw         
          do i = 2-mbc,mx+mbc
c             # if s>0 use dtdx1d(i) to compute CFL,
c             # if s<0 use dtdx1d(i-1) to compute CFL:
              cfl1d = dmax1(cfl1d, dtdx1d(i)*s(i,mw),
     &                          -dtdx1d(i-1)*s(i,mw))
          end do
      end do
c
      if (method(2) .eq. 2) then

c         # modify F fluxes for second order q_{xx} correction terms:
c         -----------------------------------------------------------

c         # apply limiter to waves:
          if (limit) then 
              call clawpack46_inlinelimiter(maxm,meqn, mwaves,mbc,mx,
     &                                      wave,s,mthlim)
          end if

          do i = 2-mbc, mx+mbc

c             # For correction terms below, need average of dtdx in cell
c             # i-1 and i.  Compute these and overwrite dtdx1d:

c             dtdx1d(i-1) = 0.5d0 * (dtdx1d(i-1) + dtdx1d(i))
              dtdxave = 0.5d0 * (dtdx1d(i-1) + dtdx1d(i))

              do m = 1,meqn
                  cqxx(i,m) = 0.d0
                  do mw = 1,mwaves

c                     # second order corrections:
                      cqxx(i,m) = cqxx(i,m) + dabs(s(i,mw))
     &                 * (1.d0 - dabs(s(i,mw))*dtdxave) * wave(i,m,mw)
                  end do
                  faddm(i,m) = faddm(i,m) + 0.5d0 * cqxx(i,m)
                  faddp(i,m) = faddp(i,m) + 0.5d0 * cqxx(i,m)
              end do
          end do
      end if

      if (method(3) .gt. 0) then

          if (method(2) .gt. 1 .and. method(3) .eq. 2) then
c             # incorporate cqxx into amdq and apdq so that it is split also.
              do i = 2-mbc, mx+mbc-1
                  do m=1,meqn
                      amdq(i,m) = amdq(i,m) + cqxx(i,m)
                      apdq(i,m) = apdq(i,m) - cqxx(i,m)
                  end do
              end do
          endif


c         # modify G fluxes for transverse propagation
c         --------------------------------------------


c         # split the left-going flux difference into down-going and up-going:
          ilr = 1
          call rpt2(ixy,maxm,meqn,mwaves,mbc,mx, q1d,q1d,
     &          aux1,aux2,aux3, ilr,amdq,bmasdq,bpasdq)

c         # modify flux below and above by B^- A^- Delta q and  B^+ A^- Delta q:
          do m=1,meqn
              do i = 2-mbc, mx+mbc
                  gupdate = 0.5d0*dtdx1d(i-1) * bmasdq(i,m)
                  gaddm(i-1,m,1) = gaddm(i-1,m,1) - gupdate
                  gaddp(i-1,m,1) = gaddp(i-1,m,1) - gupdate

                  gupdate = 0.5d0*dtdx1d(i-1) * bpasdq(i,m)
                  gaddm(i-1,m,2) = gaddm(i-1,m,2) - gupdate
                  gaddp(i-1,m,2) = gaddp(i-1,m,2) - gupdate
              end do
          end do

c         # split the right-going flux difference into down-going and up
c              -going:
          ilr = 2
          call rpt2(ixy,maxm,meqn,mwaves,mbc,mx, q1d,q1d,
     &               aux1,aux2,aux3, ilr,apdq,bmasdq,bpasdq)

c         # modify flux below and above by B^- A^+ Delta q and  B^+ A^+ Delta q:
          do m=1,meqn
              do i = 2-mbc, mx+mbc
                  gupdate = 0.5d0*dtdx1d(i) * bmasdq(i,m)
                  gaddm(i,m,1) = gaddm(i,m,1) - gupdate
                  gaddp(i,m,1) = gaddp(i,m,1) - gupdate

                  gupdate = 0.5d0*dtdx1d(i) * bpasdq(i,m)
                  gaddm(i,m,2) = gaddm(i,m,2) - gupdate
                  gaddp(i,m,2) = gaddp(i,m,2) - gupdate                  
              end do
          end do
      end if

      return
      end
